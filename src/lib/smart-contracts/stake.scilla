(* v0.3.0
stake.tyron: DID Stake <> NFT Username DNS
Tyron Self-Sovereign Identity Protocol
Copyright (C) Tyron Pungtas and its affiliates.
www.ssiprotocol.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.*)

scilla_version 0

import PairUtils BoolUtils

library DID

  let tyronAddr = 0xA3725fA67FaA3a1cAe6869C57b475ff173D98Ba7

  type DIDStatus =
    | Deployed
    | Created
    | Recovered
    | Updated
    | Deactivated
    | Locked

  type Operation =
    | Recovery
    | Update
    | Another of String
  
  type Action =
    | Add
    | Remove

  type TransferProtocol =
    | Https
    | Git

  type Endpoint =
    | Address of ByStr20
    | Uri of String TransferProtocol String   (* type, transfer protocol & uri *)

  type Document =
    | VerificationMethod of Action String ByStr33 String (* add/remove, key purpose, public key & encrypted private key *)
    | Service of Action String Endpoint (* add/remove, service ID & service *) 
  
  type Recoverer =
    | First
    | Second

  let didRecovery = Recovery
  let didUpdate = Update
  let update = "update"
  let recovery = "recovery"
  let didsr = "socialrecovery"
  let actionAdd = "add"
  let actionRemove = "remove"
  let empty_methods = Emp String ByStr33
  let empty_dkms = Emp String String
  let empty_services = Emp String ByStr20
  let empty_services_ = Emp String Endpoint
  
  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  type Error =
    | CodeWrongStatus
    | CodeWrongCaller
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeSameKey
    | CodeSameId
    | CodeNotValid
    | CodeDidLocked
 
  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongStatus            => Int32 -1
    | CodeWrongCaller            => Int32 -2
    | CodeWrongSignature         => Int32 -3
    | CodeUndefinedKey           => Int32 -4
    | CodeSameKey                => Int32 -5
    | CodeSameId                 => Int32 -6
    | CodeNotValid               => Int32 -7
    | CodeDidLocked              => Int32 -8
    end in { _exception: "Error"; code: result }
  
  let zero = Uint128 0
  let zeroByStr20 = 0x0000000000000000000000000000000000000000
  let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  let zero_bystr = builtin to_bystr zeroByStr20

  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A) =>
    match input with
    | Some v => v
    | None => default end
  let option_uint128_value = let f = @option_value Uint128 in f zero
  let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20
  let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
  let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64
  
  (* xWallet library *)
  let domain = "stake"
  
  type Beneficiary =
    | NFTUsername of String
    | Recipient of ByStr20
    
  (* NFT Username DNS library *)
  type Order =
    | Transfer of String (Option ByStr64) String Beneficiary Uint128 (Option Uint128)
    | Stake of String (Option ByStr64) String String String Uint128 ByStr20 (Option Uint128)

contract DIDStake(
  init_controller: ByStr20 with contract field verification_methods: Map String ByStr33, field deadline: Uint128,
    field init: ByStr20 with contract field services: Map String ByStr20, field dns: Map String ByStr20 end end
  )
  field did: String = ""    (* the W3C decentralized identifier *)
  field controller: ByStr20 with contract field verification_methods: Map String ByStr33, field deadline: Uint128,
    field init: ByStr20 with contract field services: Map String ByStr20, field dns: Map String ByStr20 end end
    = init_controller
  field did_status: DIDStatus = Deployed
  
  (* Verification methods @key: key purpose @value: public key of type "SchnorrSecp256k1VerificationKey2019" *)
  field verification_methods: Map String ByStr33 = empty_methods
  field dkms: Map String String = empty_dkms
  
  (* Services @key: ID @value: endpoint *)
  field services: Map String ByStr20 = empty_services
  field services_: Map String Endpoint = empty_services_
  
  field document_hash: ByStr = zero_bystr
  
  (* The block number when the DID Create operation occurred *)
  field did_created: BNum = BNum 0
  
  (* The block number when the last DID CRUD operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of transactions that have taken place *)
  field tx_number: Uint128 = zero
  
(* DID backbone *)

procedure SupportTyron( tyron: Option Uint128 )
  match tyron with
  | Some donation => 
      accept; msg = let m = { _tag: ""; _recipient: tyronAddr; _amount: donation } in one_msg m; send msg
  | None => end end
  
procedure ThrowError( err: Error )
  e = make_error err; throw e end

procedure IsOperational()
  current_status <- did_status;
  match current_status with
  | Deactivated => err = CodeWrongStatus; ThrowError err
  | Locked => err = CodeDidLocked; ThrowError err
  | _ => end end

(* Verify Schnorr signature - signed data must correspond with a controller DID key *)
procedure VerifySignature(
  id: String,
  signedData: ByStr,
  signature: Option ByStr64,
  tyron: Option Uint128
  )
  current_controller <- controller; get_did_key <-& current_controller.verification_methods[id];
  is_right_signature = let did_key = option_bystr33_value get_did_key in let sig = option_bystr64_value signature in
    builtin schnorr_verify did_key signedData sig;
    match is_right_signature with
    | True => SupportTyron tyron
    | False => err = CodeWrongSignature; ThrowError err end end

procedure VerifyDelegation( order: Order )
  latest_tx_number <- tx_number;
  match order with
  | Transfer txID signature id beneficiary amount tyron =>
      h3 = match beneficiary with
      | NFTUsername username => builtin sha256hash username
      | Recipient addr => builtin sha256hash addr end;
      signed_data = let h0 = builtin sha256hash txID in
        let h1 = builtin sha256hash latest_tx_number in let h2 = builtin sha256hash id in
        let h4 = builtin sha256hash amount in
        let donation = option_uint128_value tyron in let h5 = builtin sha256hash donation in
        let h0_1 = builtin concat h0 h1 in let h0_2 = builtin concat h0_1 h2 in
        let h0__3 = builtin concat h0_2 h3 in let h0__4 = builtin concat h0__3 h4 in
        let h0__5 = builtin concat h0__4 h5 in
        builtin to_bystr h0__5;
        VerifySignature domain signed_data signature tyron
  | Stake txID signature stakeID ssnID tossnID amount address tyron =>
      signed_data = let h0 = builtin sha256hash txID in
        let h1 = builtin sha256hash latest_tx_number in let h2 = builtin sha256hash stakeID in
        let h3 = builtin sha256hash ssnID in let h4 = builtin sha256hash tossnID in
        let h4 = builtin sha256hash amount in let h5 = builtin sha256hash address in
        let donation = option_uint128_value tyron in let h6 = builtin sha256hash donation in
        let h0_1 = builtin concat h0 h1 in let h0_2 = builtin concat h0_1 h2 in
        let h0__3 = builtin concat h0_2 h3 in let h0__4 = builtin concat h0__3 h4 in
        let h0__5 = builtin concat h0__4 h5 in let h0__6 = builtin concat h0__5 h6 in
        builtin to_bystr h0__6;
        VerifySignature domain signed_data signature tyron end end

procedure Timestamp()
  current_block <- &BLOCKNUMBER; ledger_time := current_block;
  latest_tx_number <- tx_number;
  new_tx_number = let incrementor = Uint128 1 in builtin add latest_tx_number incrementor; tx_number := new_tx_number end

procedure SaveDocument( document: Document )
  match document with
  | VerificationMethod action purpose key encrypted =>
      key_exists <- exists verification_methods[purpose];
      match action with
      | Add =>
          match key_exists with
          | True => err = CodeSameId; ThrowError err
          | False =>
              verification_methods[purpose] := key;
              dkms[purpose] := encrypted end
      | Remove => err = CodeNotValid; ThrowError err end
  | Service action id endpoint =>
      is_service <- exists services[id];
      is_service_ <- exists services_[id];
      service_exists = orb is_service is_service_;
      match action with
      | Add =>
          match service_exists with
          | True => err = CodeSameId; ThrowError err
          | False =>
              match endpoint with
              | Address addr => services[id] := addr
              | Uri eType protocol uri => services_[id] := endpoint end end
      | Remove => err = CodeNotValid; ThrowError err end end end

procedure UpdateDocument( document: Document )
  match document with
  | VerificationMethod action purpose key encrypted =>
      key_exists <- exists verification_methods[purpose];
      match action with
      | Add =>
          match key_exists with
          | True =>
              is_update = builtin eq purpose update;
              match is_update with
              | True => verification_methods[update] := key
              | False => err = CodeSameId; ThrowError err end
          | False => 
              verification_methods[purpose] := key;
              dkms[purpose] := encrypted end
      | Remove =>
          match key_exists with
          | True =>
              delete verification_methods[purpose];
              delete dkms[purpose]
          | False => err = CodeNotValid; ThrowError err end end
  | Service action id endpoint =>
      is_service <- exists services[id];
      is_service_ <- exists services_[id];
      service_exists = orb is_service is_service_;
      match action with
      | Add =>
          match service_exists with
          | True => err = CodeSameId; ThrowError err
          | False => 
              match endpoint with
              | Address addr => services[id] := addr
              | Uri eType protocol uri => services_[id] := endpoint end end
      | Remove =>
          match service_exists with
          | True => delete services[id]; delete services_[id]
          | False => err = CodeNotValid; ThrowError err end end end end

procedure ValidateDocument(
  operation: Operation,
  document: List Document
  )
  match operation with
  | Recovery => 
      verification_methods := empty_methods; dkms := empty_dkms; services := empty_services; services_ := empty_services_;
      forall document SaveDocument
  | Update => forall document UpdateDocument
  | Another id => err = CodeNotValid; ThrowError err end end

procedure HashDocument( document: Document )
  doc_hash <- document_hash;
  match document with
  | VerificationMethod action purpose key encrypted =>
      match action with
      | Add =>
          hash = let h1 = builtin sha256hash actionAdd in
            let h2 = builtin sha256hash purpose in
            let h3 = builtin sha256hash key in
            let h4 = builtin sha256hash encrypted in
            let h1_2 = builtin concat h1 h2 in
            let h1_3 = builtin concat h1_2 h3 in
            builtin concat h1_3 h4;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove in
            let h2 = builtin sha256hash purpose in
            builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_ end
  | Service action id endpoint =>
      match action with
      | Add =>
          match endpoint with
          | Uri eType transfer uri =>
              hash = let h1 = builtin sha256hash actionAdd in
                let h2 = builtin sha256hash id in
                let h3 = builtin sha256hash uri in
                let h1_2 = builtin concat h1 h2 in
                builtin concat h1_2 h3;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              document_hash := doc_hash_
          | Address addr =>
              hash = let h1 = builtin sha256hash actionAdd in
                let h2 = builtin sha256hash id in
                let h3 = builtin sha256hash addr in
                let h1_2 = builtin concat h1 h2 in
                builtin concat h1_2 h3;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              document_hash := doc_hash_ end
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove in
            let h2 = builtin sha256hash id in
            builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_ end end end

procedure VerifyDocument(
  operation: Operation,
  document: List Document,
  signature: Option ByStr64,
  tyron: Option Uint128
  )
  document_hash := zero_bystr; forall document HashDocument; doc_hash <- document_hash;
  id = match operation with
  | Recovery => recovery
  | Update => update
  | Another id => id end;
  VerifySignature id doc_hash signature tyron;
  ValidateDocument operation document end

transition DidCreate(
  signature: Option ByStr64,
  document: List Document,
  tyron: Option Uint128
  )
  current_status <- did_status;
  match current_status with
  | Deployed =>
      VerifyDocument didRecovery document signature tyron;
      new_did = let did_prefix = "did:tyron:zil:test:" in let did_suffix = builtin to_string _this_address in
        builtin concat did_prefix did_suffix; did := new_did;
      forall document SaveDocument;
      new_status = Created; did_status := new_status;
      current_block <- &BLOCKNUMBER; did_created := current_block; Timestamp
  | _ => err = CodeWrongStatus; ThrowError err end end
  
transition DidRecover(
  signature: Option ByStr64,
  document: List Document,
  tyron: Option Uint128
  )
  current_status <- did_status; current_controller <- controller;
  match current_status with
  | Created => | Recovered => | Updated =>
  | _ => err = CodeWrongStatus; ThrowError err end;
  VerifyDocument didRecovery document signature tyron;
  new_status = Recovered; did_status := new_status; Timestamp end

transition DidUpdate(
  signature: Option ByStr64,
  document: List Document,
  tyron: Option Uint128
  )
  current_status <- did_status;
  match current_status with
  | Created => | Recovered => | Updated =>
  | _ => err = CodeWrongStatus; ThrowError err end;
  VerifyDocument didUpdate document signature tyron;
  new_status = Updated; did_status := new_status; Timestamp end

transition DidDeactivate(
  signature: Option ByStr64,
  document: List Document,
  tyron: Option Uint128
  ) 
  current_status <- did_status;
  match current_status with
  | Created => | Recovered => | Updated =>
  | _ => err = CodeWrongStatus; ThrowError err end;
  VerifyDocument didRecovery document signature tyron;
  verification_methods := empty_methods; services := empty_services; services_ := empty_services_;
  new_status = Deactivated; did_status := new_status; Timestamp end

(* xWallet backbone *)

(* Receive $ZIL native funds *)
transition AddFunds()
  IsOperational; accept; Timestamp end

(* Send $ZIL to any recipient that implements the tag, e.g. "AddFunds", "", etc. *)
transition SendFunds(
  signature: Option ByStr64,
  tag: String,
  beneficiary: Beneficiary,
  tyron: Option Uint128
  )
  IsOperational; txID = "SendFunds";
  order = Transfer txID signature tag beneficiary _amount tyron; VerifyDelegation order;
  match beneficiary with
  | NFTUsername username =>
      current_controller <- controller; init <-& current_controller.init;
      get_addr <-& init.dns[username]; addr = option_bystr20_value get_addr;
      accept; msg = let m = { _tag: tag; _recipient: addr; _amount: _amount } in one_msg m; send msg
  | Recipient addr =>
      accept; msg = let m = { _tag: tag; _recipient: addr; _amount: _amount } in one_msg m; send msg end; Timestamp end

procedure FetchServiceAddr( id: String )
  current_controller <- controller; init <-& current_controller.init; 
  get_service <-& init.services[id]; addr = option_bystr20_value get_service; services[id] := addr end
  
transition Transfer(
  signature: Option ByStr64,
  addrID: String,
  beneficiary: Beneficiary,
  amount: Uint128,
  tyron: Option Uint128
  ) 
  IsOperational; txID = "Transfer";
  order = Transfer txID signature addrID beneficiary amount tyron; VerifyDelegation order;
  FetchServiceAddr addrID; get_token_addr <- services[addrID]; token_addr = option_bystr20_value get_token_addr;
  match beneficiary with
  | NFTUsername username =>
      current_controller <- controller; init <-& current_controller.init;
      get_addr <-& init.dns[username]; addr = option_bystr20_value get_addr;
      accept; msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount } in one_msg m ; send msg
  | Recipient addr =>
      accept; msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount } in one_msg m ; send msg end; Timestamp end

transition RecipientAcceptTransfer( sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

transition RecipientAcceptTransferFrom( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

transition TransferSuccessCallBack( sender: ByStr20, recipient: ByStr20, amount : Uint128 ) IsOperational end

transition TransferFromSuccessCallBack( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

transition DelegateStake(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  tyron: Option Uint128
  )
  IsOperational; txID = "DelegateStake";
  order = Stake txID signature stakeID ssnID ssnID _amount zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  FetchServiceAddr ssnID; get_ssnaddr <- services[ssnID]; ssnaddr = option_bystr20_value get_ssnaddr;
  accept; msg = let m = { _tag: "DelegateStake"; _recipient: addr; _amount: _amount;
    ssnaddr: ssnaddr } in one_msg m; send msg end

transition DelegateStakeSuccessCallBack( ssnaddr: ByStr20, amount: Uint128 ) IsOperational end

transition WithdrawStakeRewards(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  tyron: Option Uint128
  )
  IsOperational; txID = "WithdrawStakeRewards";
  order = Stake txID signature stakeID ssnID ssnID zero zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  FetchServiceAddr ssnID; get_ssnaddr <- services[ssnID]; ssnaddr = option_bystr20_value get_ssnaddr;
  accept; msg = let m = { _tag: "WithdrawStakeRewards"; _recipient: addr; _amount: zero;
    ssnaddr: ssnaddr } in one_msg m; send msg end

transition WithdrawStakeRewardsSuccessCallBack( ssnaddr: ByStr20, rewards: Uint128 ) IsOperational end  

transition WithdrawStakeAmt(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  amount: Uint128,
  tyron: Option Uint128
  )
  IsOperational; txID = "WithdrawStakeAmt";
  order = Stake txID signature stakeID ssnID ssnID amount zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  FetchServiceAddr ssnID; get_ssnaddr <- services[ssnID]; ssnaddr = option_bystr20_value get_ssnaddr;
  accept; msg = let m = { _tag: "WithdrawStakeAmt"; _recipient: addr; _amount: zero;
    ssnaddr: ssnaddr;
    amt: amount } in one_msg m; send msg end

transition WithdrawStakeAmtSuccessCallBack( ssnaddr: ByStr20, amount: Uint128 ) IsOperational end

transition CompleteWithdrawal(
  signature: Option ByStr64,
  stakeID: String,
  tyron: Option Uint128
  )
  IsOperational; txID = "CompleteWithdrawal";
  order = Stake txID signature stakeID stakeID stakeID zero zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  accept; msg = let m = { _tag: "CompleteWithdrawal"; _recipient: addr; _amount: zero } in one_msg m; send msg end

transition CompleteWithdrawalNoUnbondedStakeCallBack( amount: Uint128 ) IsOperational end

transition CompleteWithdrawalSuccessCallBack( amount: Uint128 ) IsOperational end

transition ReDelegateStake(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  tossnID: String,
  amount: Uint128,
  tyron: Option Uint128
  )
  IsOperational; txID = "ReDelegateStake";
  order = Stake txID signature stakeID ssnID tossnID amount zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  FetchServiceAddr ssnID; get_ssnaddr <- services[ssnID]; ssnaddr = option_bystr20_value get_ssnaddr;
  FetchServiceAddr tossnID; get_tossnaddr <- services[ssnID]; to_ssnaddr = option_bystr20_value get_tossnaddr;
  accept; msg = let m = { _tag: "ReDelegateStake"; _recipient: addr; _amount: zero;
    ssnaddr: ssnaddr;
    to_ssn: to_ssnaddr;
    amount: amount } in one_msg m; send msg end

transition ReDelegateStakeSuccessCallBack( ssnaddr: ByStr20, tossn: ByStr20, amount: Uint128 ) IsOperational end

transition RequestDelegatorSwap(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  tossnID: String,
  amount: Uint128,
  address: ByStr20,
  tyron: Option Uint128
  )
  IsOperational; txID = "WithdrawStakeAmt";
  order = Stake txID signature stakeID stakeID stakeID zero address tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  accept; msg = let m = { _tag: "RequestDelegatorSwap"; _recipient: addr; _amount: zero;
    new_deleg_addr: address } in one_msg m; send msg end

transition ConfirmDelegatorSwap(
  signature: Option ByStr64,
  stakeID: String,
  ssnID: String,
  tossnID: String,
  amount: Uint128,
  address: ByStr20,
  tyron: Option Uint128
  )
  IsOperational; txID = "ConfirmDelegatorSwap";
  order = Stake txID signature stakeID stakeID stakeID zero address tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  accept; msg = let m = { _tag: "ConfirmDelegatorSwap"; _recipient: addr; _amount: zero;
    requestor: address } in one_msg m; send msg end

transition RevokeDelegatorSwap(
  signature: Option ByStr64,
  stakeID: String,
  tyron: Option Uint128
  )
  IsOperational; txID = "RevokeDelegatorSwap";
  order = Stake txID signature stakeID stakeID stakeID zero zeroByStr20 tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  accept; msg = let m = { _tag: "RevokeDelegatorSwap"; _recipient: addr; _amount: zero } in one_msg m; send msg end

transition RejectDelegatorSwap(
  signature: Option ByStr64,
  stakeID: String,
  address: ByStr20,
  tyron: Option Uint128
  )
  IsOperational; txID = "RejectDelegatorSwap";
  order = Stake txID signature stakeID stakeID stakeID zero address tyron; VerifyDelegation order;
  FetchServiceAddr stakeID; get_addr <- services[stakeID]; addr = option_bystr20_value get_addr;
  accept; msg = let m = { _tag: "RejectDelegatorSwap"; _recipient: addr; _amount: zero;
    requestor: address } in one_msg m; send msg end